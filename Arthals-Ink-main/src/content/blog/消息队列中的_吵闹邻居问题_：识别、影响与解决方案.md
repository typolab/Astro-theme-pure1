---
title: 'æ¶ˆæ¯é˜Ÿåˆ—ä¸­çš„"åµé—¹é‚»å±…é—®é¢˜"ï¼šè¯†åˆ«ã€å½±å“ä¸è§£å†³æ–¹æ¡ˆ'
description: 'ç³»ç»Ÿæ€§åœ°è¯†åˆ«å’Œæ²»ç†æ¶ˆæ¯é˜Ÿåˆ—é‡Œçš„ noisy neighborï¼Œè®©å¤šç§Ÿæˆ·æµé‡ä¿æŒå…¬å¹³ä¸ç¨³å®šã€‚'
publishDate: 2025-09-20
updatedDate: 2025-09-20
tags:
  - æ¶ˆæ¯é˜Ÿåˆ—
  - ç³»ç»Ÿæ¶æ„
  - æ€§èƒ½ä¼˜åŒ–
language: ä¸­æ–‡
slug: mq-noisy-neighbor
---

## ğŸ“ æ¶ˆæ¯é˜Ÿåˆ—ä¸­çš„"åµé—¹é‚»å±…é—®é¢˜"ï¼šè¯†åˆ«ã€å½±å“ä¸è§£å†³æ–¹æ¡ˆ

### ä¸€ã€ä»€ä¹ˆæ˜¯"åµé—¹é‚»å±…é—®é¢˜"ï¼Ÿ

#### 1.1 å®šä¹‰
"åµé—¹é‚»å±…é—®é¢˜"ï¼ˆNoisy Neighbor Problemï¼‰æºäºäº‘è®¡ç®—é¢†åŸŸï¼ŒæŒ‡åœ¨å…±äº«èµ„æºç¯å¢ƒä¸­ï¼ŒæŸäº›ç§Ÿæˆ·è¿‡åº¦ä½¿ç”¨èµ„æºï¼Œå¯¼è‡´å…¶ä»–ç§Ÿæˆ·çš„æ€§èƒ½å—åˆ°å½±å“ã€‚åœ¨æ¶ˆæ¯é˜Ÿåˆ—åœºæ™¯ä¸­ï¼Œè¡¨ç°ä¸ºï¼š

- **æŸäº›æ¶ˆè´¹è€…å¤„ç†é€Ÿåº¦æ…¢**ï¼Œé•¿æ—¶é—´å ç”¨æ¶ˆæ¯
- **æŸäº›ç”Ÿäº§è€…å‘é€æ¶ˆæ¯è¿‡å¿«**ï¼Œå¯¼è‡´é˜Ÿåˆ—å †ç§¯
- **æŸäº›é˜Ÿåˆ—æ¶ˆæ¯é‡æ¿€å¢**ï¼Œå½±å“å…¶ä»–é˜Ÿåˆ—çš„å¤„ç†

#### 1.2 ç°å®åœºæ™¯ç±»æ¯”
å°±åƒä½åœ¨å…¬å¯“æ¥¼é‡Œï¼š
- æ¥¼ä¸Šé‚»å±…æ·±å¤œè£…ä¿®ï¼ˆèµ„æºå„æ–­ï¼‰
- éš”å£é‚»å±…å ç”¨å…¬å…±èµ°å»Šï¼ˆé˜Ÿåˆ—å µå¡ï¼‰
- æŸæˆ·å¤§é‡ç”¨æ°´å¯¼è‡´æ°´å‹ä¸è¶³ï¼ˆèµ„æºè€—å°½ï¼‰

### äºŒã€é—®é¢˜å‘ç”Ÿçš„å…¸å‹åœºæ™¯

#### åœºæ™¯1ï¼šç”µå•†å¤§ä¿ƒæœŸé—´

é—®é¢˜è¡¨ç°ï¼š
- è®¢å•æœåŠ¡æ¶ˆæ¯æ¿€å¢10å€
- åº“å­˜æœåŠ¡å¤„ç†å˜æ…¢
- æ”¯ä»˜å›è°ƒæ¶ˆæ¯è¢«å»¶è¿Ÿ
- ç”¨æˆ·æŠ•è¯‰æ”¶ä¸åˆ°é€šçŸ¥

æ ¹æœ¬åŸå› ï¼š
è®¢å•æ¶ˆæ¯å ç”¨äº†å¤§éƒ¨åˆ†æ¶ˆè´¹è€…çº¿ç¨‹ï¼Œå…¶ä»–ä¸šåŠ¡æ¶ˆæ¯å¾—ä¸åˆ°åŠæ—¶å¤„ç†


#### åœºæ™¯2ï¼šSaaSå¤šç§Ÿæˆ·ç³»ç»Ÿ

é—®é¢˜è¡¨ç°ï¼š
- å¤§å®¢æˆ·å¯¼å…¥100ä¸‡æ¡æ•°æ®
- å°å®¢æˆ·çš„å®æ—¶æ¶ˆæ¯è¢«é˜»å¡
- ç³»ç»Ÿå“åº”æ—¶é—´ä»100mså‡è‡³5s
- æ•´ä½“ååé‡ä¸‹é™80%

æ ¹æœ¬åŸå› ï¼š
ç¼ºä¹ç§Ÿæˆ·éš”ç¦»å’Œæµé‡æ§åˆ¶æœºåˆ¶


#### åœºæ™¯3ï¼šå¾®æœåŠ¡å¼‚æ­¥é€šä¿¡

é—®é¢˜è¡¨ç°ï¼š
- æ—¥å¿—æœåŠ¡å‘é€å¤§é‡è°ƒè¯•æ—¥å¿—
- æ ¸å¿ƒä¸šåŠ¡æ¶ˆæ¯å¤„ç†å»¶è¿Ÿ
- æ¶ˆæ¯é˜Ÿåˆ—å†…å­˜å ç”¨è¿‡é«˜
- éƒ¨åˆ†æœåŠ¡å‡ºç°è¶…æ—¶

æ ¹æœ¬åŸå› ï¼š
éå…³é”®æ¶ˆæ¯å’Œå…³é”®æ¶ˆæ¯æ··åœ¨ä¸€èµ·ï¼Œæ²¡æœ‰ä¼˜å…ˆçº§åŒºåˆ†


#### åœºæ™¯4ï¼šæ•°æ®å¤„ç†ç®¡é“

é—®é¢˜è¡¨ç°ï¼š
- æ‰¹å¤„ç†ä»»åŠ¡å æ»¡æ‰€æœ‰æ¶ˆè´¹è€…
- å®æ—¶æ•°æ®å¤„ç†è¢«é˜»å¡
- ç›‘æ§å‘Šè­¦å»¶è¿Ÿå‘é€
- æ•°æ®æ—¶æ•ˆæ€§ä¸‹é™

æ ¹æœ¬åŸå› ï¼š
æ‰¹å¤„ç†å’Œå®æ—¶å¤„ç†å…±ç”¨èµ„æºï¼Œç¼ºå°‘éš”ç¦»


### ä¸‰ã€é—®é¢˜çš„å½±å“ä¸å±å®³

#### 3.1 æ€§èƒ½å½±å“
- **å»¶è¿Ÿå¢åŠ **ï¼šP99å»¶è¿Ÿä»100mså¢åŠ åˆ°10s
- **ååé‡ä¸‹é™**ï¼šæ•´ä½“å¤„ç†èƒ½åŠ›ä¸‹é™50-80%
- **èµ„æºæµªè´¹**ï¼šCPUä½¿ç”¨ç‡é«˜ä½†æœ‰æ•ˆäº§å‡ºä½

#### 3.2 ä¸šåŠ¡å½±å“
- **ç”¨æˆ·ä½“éªŒå·®**ï¼šå“åº”æ…¢ã€è¶…æ—¶å¤š
- **æ•°æ®ä¸ä¸€è‡´**ï¼šæ¶ˆæ¯å¤„ç†é¡ºåºæ··ä¹±
- **æœåŠ¡é™çº§**ï¼šè¢«è¿«å…³é—­éƒ¨åˆ†åŠŸèƒ½

#### 3.3 è¿ç»´å½±å“
- **éš¾ä»¥å®šä½**ï¼šé—®é¢˜æºå¤´ä¸æ˜æ˜¾
- **æ‰©å®¹æ— æ•ˆ**ï¼šç®€å•åŠ æœºå™¨ä¸èƒ½è§£å†³
- **é›ªå´©é£é™©**ï¼šå¯èƒ½å¼•å‘è¿é”æ•…éšœ

### å››ã€é€šç”¨è§£å†³æ–¹æ¡ˆæ¶æ„

#### 4.1 æ ¸å¿ƒè®¾è®¡åŸåˆ™

```java
// è§£å†³æ–¹æ¡ˆçš„äº”å¤§æ”¯æŸ±
public class NoisyNeighborSolution {
    
    // 1. æµé‡æ§åˆ¶ - Rate Limiting
    private RateLimiter rateLimiter;
    
    // 2. å…¬å¹³è°ƒåº¦ - Fair Dispatch
    private FairScheduler scheduler;
    
    // 3. èµ„æºéš”ç¦» - Resource Isolation
    private ResourcePool resourcePool;
    
    // 4. ä¼˜å…ˆçº§ç®¡ç† - Priority Management
    private PriorityQueue priorityQueue;
    
    // 5. ç›‘æ§é¢„è­¦ - Monitoring & Alerting
    private MetricsCollector metrics;
}
```

### äº”ã€å…·ä½“å®ç°æ–¹æ¡ˆ

#### æ–¹æ¡ˆ1ï¼šåŸºäºä»¤ç‰Œæ¡¶çš„æµé‡æ§åˆ¶

```java
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * ä»¤ç‰Œæ¡¶é€Ÿç‡é™åˆ¶å™¨ - é€šç”¨å®ç°
 */
public class TokenBucketRateLimiter {
    
    private final int capacity;           // æ¡¶å®¹é‡
    private final int refillRate;         // æ¯ç§’è¡¥å……ä»¤ç‰Œæ•°
    private final AtomicInteger tokens;   // å½“å‰ä»¤ç‰Œæ•°
    private final ScheduledExecutorService scheduler;
    
    public TokenBucketRateLimiter(int capacity, int refillRatePerSecond) {
        this.capacity = capacity;
        this.refillRate = refillRatePerSecond;
        this.tokens = new AtomicInteger(capacity);
        this.scheduler = Executors.newScheduledThreadPool(1);
        
        // å®šæ—¶è¡¥å……ä»¤ç‰Œ
        scheduler.scheduleAtFixedRate(this::refill, 0, 1, TimeUnit.SECONDS);
    }
    
    /**
     * å°è¯•è·å–ä»¤ç‰Œ
     */
    public boolean tryAcquire() {
        return tryAcquire(1);
    }
    
    /**
     * å°è¯•è·å–å¤šä¸ªä»¤ç‰Œ
     */
    public boolean tryAcquire(int permits) {
        int current = tokens.get();
        if (current < permits) {
            return false;
        }
        return tokens.compareAndSet(current, current - permits);
    }
    
    /**
     * é˜»å¡å¼è·å–ä»¤ç‰Œ
     */
    public void acquire() throws InterruptedException {
        while (!tryAcquire()) {
            Thread.sleep(100);  // ç­‰å¾…100msåé‡è¯•
        }
    }
    
    /**
     * è¡¥å……ä»¤ç‰Œ
     */
    private void refill() {
        tokens.updateAndGet(current -> 
            Math.min(capacity, current + refillRate));
    }
}
```

#### æ–¹æ¡ˆ2ï¼šå…¬å¹³è°ƒåº¦å™¨å®ç°

```java
import java.util.concurrent.*;
import java.util.Map;

/**
 * å…¬å¹³æ¶ˆæ¯è°ƒåº¦å™¨
 */
public class FairMessageScheduler {
    
    // æ¯ä¸ªé˜Ÿåˆ—/ç§Ÿæˆ·çš„é…é¢
    private final Map<String, Integer> quotas = new ConcurrentHashMap<>();
    
    // å½“å‰å‘¨æœŸå†…çš„ä½¿ç”¨é‡
    private final Map<String, AtomicInteger> usage = new ConcurrentHashMap<>();
    
    // é¢„å–é…ç½®
    private final int defaultPrefetch = 10;
    private final int minPrefetch = 1;
    private final int maxPrefetch = 100;
    
    /**
     * è®¡ç®—åŠ¨æ€é¢„å–æ•°é‡
     */
    public int calculatePrefetchCount(String queueName) {
        // è·å–é…é¢
        int quota = quotas.getOrDefault(queueName, defaultPrefetch);
        
        // è·å–å½“å‰ä½¿ç”¨é‡
        int currentUsage = usage.computeIfAbsent(queueName, 
            k -> new AtomicInteger(0)).get();
        
        // åŠ¨æ€è°ƒæ•´ï¼šä½¿ç”¨é‡è¶Šå¤§ï¼Œé¢„å–è¶Šå°‘ï¼ˆå®ç°å…¬å¹³ï¼‰
        double usageRatio = (double) currentUsage / quota;
        int prefetch = (int) (defaultPrefetch * (1 - usageRatio * 0.8));
        
        // ç¡®ä¿åœ¨åˆç†èŒƒå›´å†…
        return Math.max(minPrefetch, Math.min(maxPrefetch, prefetch));
    }
    
    /**
     * è®°å½•æ¶ˆæ¯æ¶ˆè´¹
     */
    public void recordConsumption(String queueName, int count) {
        usage.computeIfAbsent(queueName, k -> new AtomicInteger(0))
             .addAndGet(count);
    }
    
    /**
     * é‡ç½®ä½¿ç”¨ç»Ÿè®¡ï¼ˆæ¯ä¸ªå‘¨æœŸè°ƒç”¨ï¼‰
     */
    public void resetUsage() {
        usage.clear();
    }
    
    /**
     * è®¾ç½®é˜Ÿåˆ—é…é¢
     */
    public void setQuota(String queueName, int quota) {
        quotas.put(queueName, quota);
    }
}
```

#### æ–¹æ¡ˆ3ï¼šä¼˜å…ˆçº§é˜Ÿåˆ—ç®¡ç†

```java
import java.util.concurrent.*;
import java.util.Comparator;

/**
 * ä¼˜å…ˆçº§æ¶ˆæ¯å¤„ç†å™¨
 */
public class PriorityMessageProcessor {
    
    // ä¼˜å…ˆçº§é˜Ÿåˆ—
    private final PriorityBlockingQueue<PriorityMessage> queue;
    
    // å·¥ä½œçº¿ç¨‹æ± 
    private final ExecutorService executorService;
    
    // å¤„ç†è¶…æ—¶é…ç½®
    private final long timeoutMs;
    
    public PriorityMessageProcessor(int poolSize, long timeoutMs) {
        this.queue = new PriorityBlockingQueue<>(1000, 
            Comparator.comparing(PriorityMessage::getPriority).reversed()
                      .thenComparing(PriorityMessage::getTimestamp));
        
        this.executorService = new ThreadPoolExecutor(
            poolSize / 2,  // æ ¸å¿ƒçº¿ç¨‹æ•°
            poolSize,       // æœ€å¤§çº¿ç¨‹æ•°
            60L, TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(1000),
            new ThreadPoolExecutor.CallerRunsPolicy()
        );
        
        this.timeoutMs = timeoutMs;
        
        // å¯åŠ¨æ¶ˆè´¹çº¿ç¨‹
        startConsumers(poolSize);
    }
    
    /**
     * æäº¤æ¶ˆæ¯
     */
    public boolean submit(String messageId, Object payload, int priority) {
        PriorityMessage message = new PriorityMessage(
            messageId, payload, priority, System.currentTimeMillis()
        );
        
        // æ£€æŸ¥æ¶ˆæ¯æ˜¯å¦è¿‡æœŸ
        if (isExpired(message)) {
            handleExpiredMessage(message);
            return false;
        }
        
        return queue.offer(message);
    }
    
    /**
     * å¯åŠ¨æ¶ˆè´¹è€…
     */
    private void startConsumers(int count) {
        for (int i = 0; i < count; i++) {
            executorService.submit(this::consume);
        }
    }
    
    /**
     * æ¶ˆè´¹é€»è¾‘
     */
    private void consume() {
        while (!Thread.currentThread().isInterrupted()) {
            try {
                PriorityMessage message = queue.poll(1, TimeUnit.SECONDS);
                if (message != null) {
                    processWithTimeout(message);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }
    
    /**
     * å¸¦è¶…æ—¶çš„å¤„ç†
     */
    private void processWithTimeout(PriorityMessage message) {
        Future<?> future = executorService.submit(() -> 
            processMessage(message)
        );
        
        try {
            future.get(timeoutMs, TimeUnit.MILLISECONDS);
        } catch (TimeoutException e) {
            future.cancel(true);
            handleTimeout(message);
        } catch (Exception e) {
            handleError(message, e);
        }
    }
    
    // æ¶ˆæ¯ç±»å®šä¹‰
    static class PriorityMessage {
        private final String id;
        private final Object payload;
        private final int priority;
        private final long timestamp;
        
        // æ„é€ å‡½æ•°å’Œgetterçœç•¥...
    }
    
    // æŠ½è±¡æ–¹æ³•ï¼Œå­ç±»å®ç°
    protected abstract void processMessage(PriorityMessage message);
    protected abstract void handleTimeout(PriorityMessage message);
    protected abstract void handleError(PriorityMessage message, Exception e);
    protected abstract void handleExpiredMessage(PriorityMessage message);
    protected abstract boolean isExpired(PriorityMessage message);
}
```

#### æ–¹æ¡ˆ4ï¼šèµ„æºéš”ç¦»æ± 

```java
import java.util.concurrent.*;
import java.util.Map;

/**
 * èµ„æºéš”ç¦»æ±  - ä¸ºä¸åŒç§Ÿæˆ·/é˜Ÿåˆ—åˆ†é…ç‹¬ç«‹èµ„æº
 */
public class IsolatedResourcePool {
    
    // æ¯ä¸ªç§Ÿæˆ·çš„ç‹¬ç«‹çº¿ç¨‹æ± 
    private final Map<String, ExecutorService> tenantPools;
    
    // å…±äº«æ± ï¼ˆç”¨äºä½ä¼˜å…ˆçº§ä»»åŠ¡ï¼‰
    private final ExecutorService sharedPool;
    
    // èµ„æºé…ç½®
    private final Map<String, ResourceConfig> configs;
    
    public IsolatedResourcePool() {
        this.tenantPools = new ConcurrentHashMap<>();
        this.configs = new ConcurrentHashMap<>();
        
        // åˆ›å»ºå…±äº«æ± 
        this.sharedPool = new ForkJoinPool(
            Runtime.getRuntime().availableProcessors(),
            ForkJoinPool.defaultForkJoinWorkerThreadFactory,
            null, true
        );
    }
    
    /**
     * ä¸ºç§Ÿæˆ·åˆ†é…èµ„æº
     */
    public void allocateResources(String tenant, ResourceConfig config) {
        configs.put(tenant, config);
        
        // åˆ›å»ºç‹¬ç«‹çº¿ç¨‹æ± 
        ExecutorService pool = new ThreadPoolExecutor(
            config.minThreads,
            config.maxThreads,
            60L, TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(config.queueSize),
            new ThreadFactory() {
                private final AtomicInteger counter = new AtomicInteger(0);
                @Override
                public Thread newThread(Runnable r) {
                    Thread t = new Thread(r);
                    t.setName("Pool-" + tenant + "-" + counter.getAndIncrement());
                    t.setPriority(config.threadPriority);
                    return t;
                }
            },
            config.rejectionPolicy
        );
        
        tenantPools.put(tenant, pool);
    }
    
    /**
     * æäº¤ä»»åŠ¡åˆ°å¯¹åº”çš„èµ„æºæ± 
     */
    public Future<?> submit(String tenant, Runnable task) {
        ExecutorService pool = tenantPools.get(tenant);
        
        if (pool == null) {
            // æ²¡æœ‰ä¸“å±æ± ï¼Œä½¿ç”¨å…±äº«æ± 
            return sharedPool.submit(task);
        }
        
        return pool.submit(task);
    }
    
    /**
     * èµ„æºé…ç½®
     */
    static class ResourceConfig {
        int minThreads = 1;
        int maxThreads = 10;
        int queueSize = 100;
        int threadPriority = Thread.NORM_PRIORITY;
        RejectedExecutionHandler rejectionPolicy = 
            new ThreadPoolExecutor.CallerRunsPolicy();
        
        // Builderæ¨¡å¼æ„é€ ï¼Œçœç•¥...
    }
}
```

#### æ–¹æ¡ˆ5ï¼šæ™ºèƒ½ç›‘æ§ä¸è‡ªé€‚åº”è°ƒæ•´

```java
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;

/**
 * è‡ªé€‚åº”ç›‘æ§å™¨ - æ ¹æ®è¿è¡ŒæŒ‡æ ‡è‡ªåŠ¨è°ƒæ•´å‚æ•°
 */
public class AdaptiveMonitor {
    
    // æ€§èƒ½æŒ‡æ ‡
    private final Map<String, QueueMetrics> metrics;
    
    // è°ƒæ•´ç­–ç•¥
    private final AdaptiveStrategy strategy;
    
    // ç›‘æ§å‘¨æœŸ
    private final ScheduledExecutorService scheduler;
    
    public AdaptiveMonitor(AdaptiveStrategy strategy) {
        this.metrics = new ConcurrentHashMap<>();
        this.strategy = strategy;
        this.scheduler = Executors.newScheduledThreadPool(1);
        
        // æ¯30ç§’æ‰§è¡Œä¸€æ¬¡è‡ªé€‚åº”è°ƒæ•´
        scheduler.scheduleAtFixedRate(
            this::performAdaptation, 30, 30, TimeUnit.SECONDS
        );
    }
    
    /**
     * è®°å½•å¤„ç†æŒ‡æ ‡
     */
    public void recordProcessing(String queue, long duration, boolean success) {
        QueueMetrics m = metrics.computeIfAbsent(queue, 
            k -> new QueueMetrics(queue));
        
        m.recordProcessing(duration, success);
    }
    
    /**
     * æ‰§è¡Œè‡ªé€‚åº”è°ƒæ•´
     */
    private void performAdaptation() {
        metrics.forEach((queue, metric) -> {
            AdaptiveAction action = strategy.analyze(metric);
            applyAction(queue, action);
            metric.reset();  // é‡ç½®ç»Ÿè®¡
        });
    }
    
    /**
     * åº”ç”¨è°ƒæ•´åŠ¨ä½œ
     */
    private void applyAction(String queue, AdaptiveAction action) {
        switch (action.type) {
            case INCREASE_CONCURRENCY:
                increaseConcurrency(queue, action.value);
                break;
            case DECREASE_CONCURRENCY:
                decreaseConcurrency(queue, action.value);
                break;
            case ADJUST_RATE_LIMIT:
                adjustRateLimit(queue, action.value);
                break;
            case ENABLE_CIRCUIT_BREAKER:
                enableCircuitBreaker(queue);
                break;
            default:
                // No action needed
        }
    }
    
    /**
     * é˜Ÿåˆ—æŒ‡æ ‡
     */
    static class QueueMetrics {
        private final String queue;
        private final AtomicLong totalProcessed = new AtomicLong(0);
        private final AtomicLong totalFailed = new AtomicLong(0);
        private final AtomicLong totalDuration = new AtomicLong(0);
        private final AtomicLong maxDuration = new AtomicLong(0);
        
        public QueueMetrics(String queue) {
            this.queue = queue;
        }
        
        public void recordProcessing(long duration, boolean success) {
            if (success) {
                totalProcessed.incrementAndGet();
            } else {
                totalFailed.incrementAndGet();
            }
            totalDuration.addAndGet(duration);
            
            // æ›´æ–°æœ€å¤§å¤„ç†æ—¶é—´
            long currentMax = maxDuration.get();
            while (duration > currentMax) {
                if (maxDuration.compareAndSet(currentMax, duration)) {
                    break;
                }
                currentMax = maxDuration.get();
            }
        }
        
        public double getSuccessRate() {
            long total = totalProcessed.get() + totalFailed.get();
            return total > 0 ? (double) totalProcessed.get() / total : 1.0;
        }
        
        public double getAverageDuration() {
            long count = totalProcessed.get();
            return count > 0 ? (double) totalDuration.get() / count : 0;
        }
        
        public void reset() {
            totalProcessed.set(0);
            totalFailed.set(0);
            totalDuration.set(0);
            maxDuration.set(0);
        }
    }
    
    /**
     * è‡ªé€‚åº”ç­–ç•¥æ¥å£
     */
    interface AdaptiveStrategy {
        AdaptiveAction analyze(QueueMetrics metrics);
    }
    
    /**
     * è‡ªé€‚åº”åŠ¨ä½œ
     */
    static class AdaptiveAction {
        enum Type {
            NO_ACTION,
            INCREASE_CONCURRENCY,
            DECREASE_CONCURRENCY,
            ADJUST_RATE_LIMIT,
            ENABLE_CIRCUIT_BREAKER
        }
        
        final Type type;
        final int value;
        
        AdaptiveAction(Type type, int value) {
            this.type = type;
            this.value = value;
        }
    }
    
    // æŠ½è±¡æ–¹æ³•ï¼Œå­ç±»å®ç°
    protected abstract void increaseConcurrency(String queue, int delta);
    protected abstract void decreaseConcurrency(String queue, int delta);
    protected abstract void adjustRateLimit(String queue, int newLimit);
    protected abstract void enableCircuitBreaker(String queue);
}
```

### å…­ã€æ¡†æ¶é›†æˆç¤ºä¾‹

#### 6.1 Spring Boot + RabbitMQé›†æˆ

```java
@Configuration
@EnableRabbit
public class RabbitMQNoisyNeighborConfig {
    
    @Value("${mq.noisy-neighbor.enabled:false}")
    private boolean enableProtection;
    
    @Value("${mq.rate-limit:100}")
    private int rateLimit;
    
    @Value("${mq.prefetch:10}")
    private int prefetchCount;
    
    @Bean
    public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(
            ConnectionFactory connectionFactory) {
        
        SimpleRabbitListenerContainerFactory factory = 
            new SimpleRabbitListenerContainerFactory();
        factory.setConnectionFactory(connectionFactory);
        
        if (enableProtection) {
            // å¯ç”¨é˜²å™ªä¿æŠ¤
            factory.setPrefetchCount(prefetchCount);
            factory.setConcurrentConsumers(3);
            factory.setMaxConcurrentConsumers(10);
            factory.setConsumerBatchEnabled(false);
            
            // è®¾ç½®æ¶ˆæ¯æ‹¦æˆªå™¨
            factory.setAdviceChain(
                rateLimitAdvice(),
                retryAdvice(),
                circuitBreakerAdvice()
            );
        }
        
        return factory;
    }
    
    @Bean
    public MethodInterceptor rateLimitAdvice() {
        return invocation -> {
            // é€Ÿç‡é™åˆ¶é€»è¾‘
            if (!rateLimiter.tryAcquire()) {
                throw new RateLimitException("Rate limit exceeded");
            }
            return invocation.proceed();
        };
    }
}
```

#### 6.2 Kafkaé›†æˆç¤ºä¾‹

```java
@Configuration
@EnableKafka
public class KafkaNoisyNeighborConfig {
    
    @Bean
    public ConcurrentKafkaListenerContainerFactory<String, Object> 
            kafkaListenerContainerFactory() {
        
        ConcurrentKafkaListenerContainerFactory<String, Object> factory = 
            new ConcurrentKafkaListenerContainerFactory<>();
        
        factory.setConsumerFactory(consumerFactory());
        
        // é…ç½®é˜²å™ªå‚æ•°
        factory.setConcurrency(3);  // å¹¶å‘æ¶ˆè´¹è€…æ•°
        factory.getContainerProperties().setPollTimeout(3000);
        factory.getContainerProperties().setIdleBetweenPolls(1000);
        
        // è®¾ç½®æ‰¹é‡æ¶ˆè´¹
        factory.setBatchListener(true);
        factory.getContainerProperties().setMaxPollRecordsConfig(100);
        
        // è®¾ç½®é”™è¯¯å¤„ç†å™¨
        factory.setCommonErrorHandler(new DefaultErrorHandler(
            new FixedBackOff(1000L, 3L)
        ));
        
        return factory;
    }
}
```

### ä¸ƒã€æ€§èƒ½æµ‹è¯•ä¸è°ƒä¼˜

#### 7.1 åŸºå‡†æµ‹è¯•ä»£ç 

```java
public class PerformanceBenchmark {
    
    public static void main(String[] args) {
        // æµ‹è¯•åœºæ™¯é…ç½®
        BenchmarkConfig config = new BenchmarkConfig()
            .setProducerCount(10)      // ç”Ÿäº§è€…æ•°é‡
            .setConsumerCount(5)       // æ¶ˆè´¹è€…æ•°é‡
            .setMessageCount(100000)   // æ¶ˆæ¯æ€»é‡
            .setMessageSize(1024)      // æ¶ˆæ¯å¤§å°(bytes)
            .setNoisyRatio(0.2);       // å™ªå£°æ¯”ä¾‹(20%çš„å¤§æ¶ˆæ¯)
        
        // è¿è¡Œæµ‹è¯•
        BenchmarkResult result = runBenchmark(config);
        
        // è¾“å‡ºç»“æœ
        System.out.println("=== Performance Benchmark Results ===");
        System.out.println("Throughput: " + result.throughput + " msg/s");
        System.out.println("P50 Latency: " + result.p50Latency + " ms");
        System.out.println("P99 Latency: " + result.p99Latency + " ms");
        System.out.println("Success Rate: " + result.successRate + "%");
        System.out.println("Resource Usage: CPU=" + result.cpuUsage + 
                         "%, Memory=" + result.memoryUsage + "MB");
    }
}
```

### å…«ã€æœ€ä½³å®è·µæ€»ç»“

#### 8.1 è®¾è®¡åŸåˆ™
1. **é¢„é˜²ä¼˜äºæ²»ç–—**ï¼šåœ¨è®¾è®¡é˜¶æ®µå°±è€ƒè™‘é˜²å™ª
2. **æ¸è¿›å¼ä¼˜åŒ–**ï¼šå…ˆç®€å•æ–¹æ¡ˆï¼Œé€æ­¥å®Œå–„
3. **å¯è§‚æµ‹æ€§ä¼˜å…ˆ**ï¼šå…ˆå»ºç«‹ç›‘æ§ï¼Œå†ä¼˜åŒ–
4. **ä¸šåŠ¡ä¼˜å…ˆçº§**ï¼šä¿æŠ¤æ ¸å¿ƒä¸šåŠ¡ï¼Œå®¹å¿è¾¹ç¼˜ä¸šåŠ¡

#### 8.2 å®æ–½æ­¥éª¤
1. **è¯†åˆ«é—®é¢˜**ï¼šé€šè¿‡ç›‘æ§å‘ç°åµé—¹é‚»å±…
2. **é‡åŒ–å½±å“**ï¼šè¯„ä¼°å¯¹ä¸šåŠ¡çš„å…·ä½“å½±å“
3. **é€‰æ‹©æ–¹æ¡ˆ**ï¼šæ ¹æ®åœºæ™¯é€‰æ‹©åˆé€‚æ–¹æ¡ˆ
4. **é€æ­¥å®æ–½**ï¼šå°æ­¥å¿«è·‘ï¼ŒæŒç»­éªŒè¯
5. **æŒç»­ä¼˜åŒ–**ï¼šæ ¹æ®æ•ˆæœè°ƒæ•´å‚æ•°

#### 8.3 é¿å‘æŒ‡å—
- âŒ **ä¸è¦**ï¼šç›²ç›®å¢åŠ æœºå™¨èµ„æº
- âŒ **ä¸è¦**ï¼šä¸€åˆ€åˆ‡çš„é™æµç­–ç•¥
- âŒ **ä¸è¦**ï¼šå¿½è§†ç›‘æ§å’Œå‘Šè­¦
- âœ… **è¦**ï¼šåŒºåˆ†ä¸šåŠ¡ä¼˜å…ˆçº§
- âœ… **è¦**ï¼šè®¾ç½®åˆç†çš„è¶…æ—¶æ—¶é—´
- âœ… **è¦**ï¼šä¿ç•™é™çº§æ–¹æ¡ˆ
